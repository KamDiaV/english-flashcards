{"version":3,"file":"static/js/522.ee99b57d.chunk.js","mappings":"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","sources":["webpack://english-flashcards/./src/components/words/AddWordForm.module.scss?bbbb","components/words/AddWordForm.jsx","hooks/useForm.js","webpack://english-flashcards/./src/pages/AddWordPage.module.scss?ab5a","pages/AddWordPage.jsx","api/words.js","../node_modules/@tanstack/query-core/src/mutationObserver.ts","../node_modules/@tanstack/react-query/src/useMutation.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"form\":\"AddWordForm_form__dWTz2\",\"field\":\"AddWordForm_field__EmF9I\",\"input\":\"AddWordForm_input__3QFiL\",\"button\":\"AddWordForm_button__QohLw\",\"success\":\"AddWordForm_success__baxP2\",\"error\":\"AddWordForm_error__+FFlK\"};","import React from 'react'\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\nimport { addWord }                     from '../../api/words'\nimport { useForm }                     from '../../hooks/useForm'\nimport styles                          from './AddWordForm.module.scss'\n\nconst FIELDS = [\n  { name: 'english',      label: 'Слово (англ.)',    required: true },\n  { name: 'transcription',label: 'Транскрипция' },\n  { name: 'russian',      label: 'Перевод',          required: true },\n  { name: 'tags',         label: 'Тема' }\n]\n\nexport default function AddWordForm() {\n  const qc = useQueryClient()\n\n  const [newWord, handleChange, resetForm] = useForm({\n    english: '', transcription: '', russian: '', tags: ''\n  })\n  const [success, setSuccess] = React.useState(false)\n  const [error,   setError]   = React.useState('')\n\n  const mutation = useMutation(\n    addWord,\n    {\n      onSuccess: () => {\n        qc.invalidateQueries(['words'])\n        setSuccess(true)\n        setError('')\n        resetForm()\n      },\n      onError: () => {\n        setError('Не удалось добавить слово')\n        setSuccess(false)\n      }\n    }\n  )\n\n  const onSubmit = e => {\n    e.preventDefault()\n    setSuccess(false)\n    setError('')\n    mutation.mutate(newWord)\n  }\n\n  return (\n    <form onSubmit={onSubmit} className={styles.form}>\n      {FIELDS.map(({name,label,required}) => (\n        <label key={name} className={styles.field}>\n          {label}:\n          <input\n            name={name}\n            value={newWord[name]}\n            onChange={handleChange}\n            required={required}\n            className={styles.input}\n          />\n        </label>\n      ))}\n\n      <button\n        type=\"submit\"\n        disabled={mutation.isLoading}\n        className={styles.button}\n      >\n        {mutation.isLoading ? 'Добавляю…' : 'Добавить'}\n      </button>\n\n      {success && <p className={styles.success}>✅ Добавлено!</p>}\n      {error   && <p className={styles.error}>❌ {error}</p>}\n    </form>\n  )\n}\n","import { useState } from 'react'\n\nexport function useForm(initial) {\n  const [values, setValues] = useState(initial)\n  const handleChange = e => {\n    const { name, value } = e.target\n    setValues(prev => ({ ...prev, [name]: value }))\n  }\n  const reset = () => setValues(initial)\n  return [values, handleChange, reset]\n}\n","// extracted by mini-css-extract-plugin\nexport default {\"addWordPage\":\"AddWordPage_addWordPage__9Y-qK\",\"title\":\"AddWordPage_title__9iihw\",\"formWrapper\":\"AddWordPage_formWrapper__l50-f\"};","import React from 'react';\nimport AddWordForm from '../components/words/AddWordForm';\nimport styles from './AddWordPage.module.scss';\n\nexport default function AddWordPage() {\n  return (\n    <div className={styles.addWordPage}>\n      <h2 className={styles.title}>Добавить новое слово</h2>\n      <div className={styles.formWrapper}>\n        <AddWordForm />\n      </div>\n    </div>\n  );\n}\n","import axios from 'axios'\n\nconst API_URL = process.env.REACT_APP_API_URL\n\nexport const STORAGE_KEY_ADDED   = 'addedWords'\nexport const STORAGE_KEY_DELETED = 'deletedWords'\n\n/**\n * Получаем данные с сервера (без учёта локальных изменений)\n */\nexport function fetchWordsFromServer() {\n  return axios\n    .get(`${API_URL}/words`)\n    .then(res => res.data)\n}\n\n/**\n * Добавляем новое слово\n */\nexport function addWordOnServer(word) {\n  return axios\n    .post(`${API_URL}/words`, word)\n    .then(res => res.data)\n}\n\n/**\n * Обновляем слово на сервере\n */\nexport function updateWordOnServer(word) {\n  return axios\n    .put(`${API_URL}/words/${word.id}`, word)\n    .then(res => res.data)\n}\n\n/**\n * Удаляем слово на сервере\n */\nexport function deleteWordOnServer(id) {\n  return axios.delete(`${API_URL}/words/${id}`)\n}\n\n/**\n * Обёртка: POST + локальное сохранение\n */\nexport async function addWord(word) {\n  const data = await addWordOnServer(word)\n  const id = typeof data.id === 'number' ? data.id : `local-${Date.now()}`\n\n  const entry = {\n    id,\n    english: word.english,\n    transcription: word.transcription,\n    russian: word.russian,\n    tags: word.tags\n  }\n\n  const stored = JSON.parse(localStorage.getItem(STORAGE_KEY_ADDED) || '[]')\n  localStorage.setItem(\n    STORAGE_KEY_ADDED,\n    JSON.stringify([...stored, entry])\n  )\n\n  return entry\n}\n\n/**\n * Обёртка: PUT + локальная синхронизация (для редактирования локальных слов)\n */\nexport async function updateWord(word) {\n  const data = await updateWordOnServer(word)\n  const id = typeof data.id === 'number' ? data.id : word.id\n\n  const entry = {\n    id,\n    english:      word.english,\n    transcription: word.transcription,\n    russian:      word.russian,\n    tags:         word.tags\n  }\n\n  const stored = JSON.parse(localStorage.getItem(STORAGE_KEY_ADDED) || '[]')\n    .filter(w => String(w.id) !== String(id))\n  localStorage.setItem(\n    STORAGE_KEY_ADDED,\n    JSON.stringify([...stored, entry])\n  )\n\n  return entry\n}\n\n/**\n * Обёртка: DELETE + пометка в deletedWords\n */\nexport async function deleteWord(id) {\n  if (!String(id).startsWith('local-')) {\n    await deleteWordOnServer(id)\n  }\n\n  const added = JSON.parse(localStorage.getItem(STORAGE_KEY_ADDED) || '[]')\n    .filter(w => String(w.id) !== String(id))\n  localStorage.setItem(\n    STORAGE_KEY_ADDED,\n    JSON.stringify(added)\n  )\n\n  const deleted = JSON.parse(localStorage.getItem(STORAGE_KEY_DELETED) || '[]')\n  if (!deleted.includes(String(id))) {\n    deleted.push(String(id))\n    localStorage.setItem(\n      STORAGE_KEY_DELETED,\n      JSON.stringify(deleted)\n    )\n  }\n\n  return id\n}\n\n/**\n * Получить слова серверные и локальные:\n *  1) Фетчим с сервера\n *  2) Отрезаем удалённые (deletedWords)\n *  3) Заменяем серверные на локальные правки (addedWords)\n *  4) Добавляем полностью новые из addedWords\n */\nexport async function fetchMergedWords() {\n  const serverWords = await fetchWordsFromServer()\n  const deleted = JSON.parse(localStorage.getItem(STORAGE_KEY_DELETED) || '[]')\n  const added = JSON.parse(localStorage.getItem(STORAGE_KEY_ADDED) || '[]')\n\n  const filtered = serverWords.filter(w => !deleted.includes(String(w.id)))\n\n  const merged = filtered.map(w =>\n    added.find(a => String(a.id) === String(w.id)) || w\n  )\n\n  const extras = added.filter(a =>\n    !filtered.find(w => String(w.id) === String(a.id))\n  )\n\n  return [...merged, ...extras]\n}\n","import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  MutateOptions,\n  MutationObserverBaseResult,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\ninterface NotifyOptions {\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  private client: QueryClient\n  private currentResult!: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >\n  private currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  private mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options?: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options\n    this.options = this.client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this,\n      })\n    }\n    this.currentMutation?.setOptions(this.options)\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.updateResult()\n\n    // Determine which callbacks to trigger\n    const notifyOptions: NotifyOptions = {\n      listeners: true,\n    }\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true\n    }\n\n    this.notify(notifyOptions)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.currentResult\n  }\n\n  reset(): void {\n    this.currentMutation = undefined\n    this.updateResult()\n    this.notify({ listeners: true })\n  }\n\n  mutate(\n    variables?: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.mutateOptions = options\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this)\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, {\n      ...this.options,\n      variables:\n        typeof variables !== 'undefined' ? variables : this.options.variables,\n    })\n\n    this.currentMutation.addObserver(this)\n\n    return this.currentMutation.execute()\n  }\n\n  private updateResult(): void {\n    const state = this.currentMutation\n      ? this.currentMutation.state\n      : getDefaultState<TData, TError, TVariables, TContext>()\n\n    const result: MutationObserverBaseResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    > = {\n      ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    }\n\n    this.currentResult = result as MutationObserverResult<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >\n  }\n\n  private notify(options: NotifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          this.mutateOptions.onSuccess?.(\n            this.currentResult.data!,\n            this.currentResult.variables!,\n            this.currentResult.context!,\n          )\n          this.mutateOptions.onSettled?.(\n            this.currentResult.data!,\n            null,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        } else if (options.onError) {\n          this.mutateOptions.onError?.(\n            this.currentResult.error!,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n          this.mutateOptions.onSettled?.(\n            undefined,\n            this.currentResult.error,\n            this.currentResult.variables!,\n            this.currentResult.context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      if (options.listeners) {\n        this.listeners.forEach(({ listener }) => {\n          listener(this.currentResult)\n        })\n      }\n    })\n  }\n}\n","'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  notifyManager,\n  parseMutationArgs,\n} from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport { shouldThrowError } from './utils'\nimport type { MutationFunction, MutationKey } from '@tanstack/query-core'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n"],"names":["FIELDS","name","label","required","AddWordForm","qc","useQueryClient","newWord","handleChange","resetForm","initial","values","setValues","useState","e","value","target","prev","reset","useForm","english","transcription","russian","tags","success","setSuccess","React","error","setError","mutation","useMutation","addWord","onSuccess","invalidateQueries","onError","_jsxs","onSubmit","preventDefault","mutate","className","styles","form","children","map","_ref","field","_jsx","onChange","input","type","disabled","isLoading","button","AddWordPage","addWordPage","title","formWrapper","API_URL","process","STORAGE_KEY_ADDED","STORAGE_KEY_DELETED","async","word","data","axios","post","then","res","addWordOnServer","entry","id","Date","now","stored","JSON","parse","localStorage","getItem","setItem","stringify","updateWord","put","updateWordOnServer","filter","w","String","deleteWord","startsWith","delete","deleteWordOnServer","added","deleted","includes","push","fetchMergedWords","serverWords","get","filtered","find","a","MutationObserver","Subscribable","constructor","client","options","super","this","setOptions","bindMethods","updateResult","bind","_this$currentMutation","prevOptions","defaultMutationOptions","shallowEqualObjects","getMutationCache","notify","currentMutation","observer","onUnsubscribe","_this$currentMutation2","hasListeners","removeObserver","onMutationUpdate","action","notifyOptions","listeners","getCurrentResult","currentResult","undefined","variables","mutateOptions","build","addObserver","execute","state","getDefaultState","result","status","isSuccess","isError","isIdle","notifyManager","batch","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","call","context","onSettled","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","forEach","listener","arg1","arg2","arg3","queryClient","useSyncExternalStore","onStoreChange","subscribe","batchCalls","shouldThrowError","useErrorBoundary","noop"],"sourceRoot":""}